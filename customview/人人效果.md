# 人人效果demo #
目标效果:

![](/imgs/cardDemo.gif)


实现思路:
1.LayoutManager实现卡片层叠

    /**
	 * 层叠式卡片布局管理器
	 * Created by 曾丽 on 2017/11/13.
	 */
	
	public class OverLayCardLayoutManager extends RecyclerView.LayoutManager {

    private CardConfig config;

    public OverLayCardLayoutManager(CardConfig config) {
        this.config = config;
    }

    @Override
    public RecyclerView.LayoutParams generateDefaultLayoutParams() {
        return new RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
    }

    @Override
    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        detachAndScrapAttachedViews(recycler);
        int itemCount = getItemCount();
        if (itemCount >= config.maxShowCount) {
            //从可见的最底层view开始layout,依次层叠上去
            for (int position = itemCount - config.maxShowCount; position < itemCount; position++) {
                View view = recycler.getViewForPosition(position);
                addView(view);
                measureChildWithMargins(view, 0, 0);
                int widthSpace = getWidth() - getDecoratedMeasuredWidth(view);
                int heightSpace = getHeight() - getDecoratedMeasuredHeight(view);
                //布局时,将childview居中处理
                layoutDecoratedWithMargins(view, widthSpace / 2, heightSpace / 2,
                        widthSpace / 2 + getDecoratedMeasuredWidth(view), heightSpace / 2 + getDecoratedMeasuredHeight(view));

                /**
                 * TopView的Scale 为1，translationY 0
                 * 每一级Scale相差0.05f，translationY相差7dp左右
                 *
                 * 观察人人影视的UI，拖动时，topView被拖动，Scale不变，一直为1.
                 * top-1View 的Scale慢慢变化至1，translation也慢慢恢复0
                 * top-2View的Scale慢慢变化至 top-1View的Scale，translation 也慢慢变化只top-1View的translation
                 * top-3View的Scale要变化，translation岿然不动
                 */

                //第几层 ,如果itemcout为10,最后一个tioview9为第0层
                int level = itemCount - position - 1;
                //除顶层外做缩放和位移
                if (level > 0) {
                    //每一层做x方向的缩小
                    view.setScaleX(1 - level * config.scaleGap);
                    //可见的最底层和倒数第二层的y缩放向下位移相同
                    level = level == config.maxShowCount - 1 ? level - 1 : level;
                    //y方向的缩小
                    view.setScaleY(1 - level * config.scaleGap);
                    //向下的位移
                    view.setTranslationY(level * config.transYGap);
                }
            }
        }
    }
}

2.ItemTouchHelper实现滑动切换

    /**
	 * 人人的滑动回调
	 * Created by 曾丽 on 2017/11/13.
	 */
	
	public class RenRenCallBack extends ItemTouchHelper.SimpleCallback {

    public RenRenCallBack(int dragDirs, int swipeDirs) {
        super(dragDirs, swipeDirs);
    }

    @Override
    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) {
        return false;
    }

    @Override
    public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {
        //实现数据的循环
        String item = datas.remove(viewHolder.getLayoutPosition());
        datas.add(0, item);
        adapter.notifyDataSetChanged();
    }

	}

	RenRenCallBack callBack = new RenRenCallBack(0, ItemTouchHelper.UP);
        ItemTouchHelper touchHelper = new ItemTouchHelper(callBack);
        touchHelper.attachToRecyclerView(rv1);

3.滑动时动画

	/**
	 * 人人的滑动回调
	 * Created by 曾丽 on 2017/11/13.
	 */
	
	public class RenRenCallBack extends ItemTouchHelper.SimpleCallback {

    @Override
    public void onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) {
        super.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive);
        //添加切换动画效果
        //先根据滑动的dxdy 算出动画的比例系数fraction
        double swipeValue = Math.sqrt(dX * dX + dY * dY);
        double fraction = swipeValue / getThreshold(viewHolder);
        //边界修正 最大为1
        fraction = fraction > 1 ? 1 : fraction;
        //对每个ChildView进行缩放 位移
        int childCount = recyclerView.getChildCount();
        for (int i = 0; i < childCount; i++) {
            View child = recyclerView.getChildAt(i);
            //第几层 如果childcoutnwei10 最后一个item(9) 为第0层
            int level = childCount - i - 1;
            //除最顶层外做缩放和位移
            if (level > 0) {
                //每一层做x方向的缩小
                child.setScaleX((float) (1 - level * config.scaleGap + fraction * config.scaleGap));
                //可见的最底层不做y方向的缩放和位移
                if (level < config.maxShowCount - 1) {
                    //y方向的缩小
                    child.setScaleY((float) (1 - level * config.scaleGap + fraction * config.scaleGap));
                    //向下的位移
                    child.setTranslationY((float) (level * config.transYGap - fraction * config.transYGap));
                }
            }
        }
    }

    //水平方向是否可以被回收掉的阈值
    public float getThreshold(RecyclerView.ViewHolder viewHolder) {
        return rv.getHeight() * getSwipeThreshold(viewHolder);
    }

}