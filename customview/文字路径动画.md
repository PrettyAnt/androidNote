# 文字路径动画 #

参考:

github:    [TextPathView](https://github.com/totond/TextPathView)

博客:    [文字路径动画控件TextPathView解析](https://juejin.im/post/5a9677b16fb9a063375765ad)

## 目标效果 ##

![](/imgs/textPathAnim.gif)

### 文字路径的获取 ###

    /**
     * 初始化路径
     */
    private void initPath() {
        mTextWitdh = mPaint.measureText(mText);
        mTextHeight = mPaint.descent() - mPaint.ascent();
        Log.d(TAG, "文字宽度=" + mTextWitdh + ";文字高度=" + mTextHeight);
        mTextPath = new Path();
        drawPath = new Path();
        //获取文字的路径
        mPaint.getTextPath(mText, 0, mText.length(), 0, padding + mPaint.getTextSize(), mTextPath);
        mPathMeasure = new PathMeasure(mTextPath, false);
        //初始化文字路径总长度
        mLength = mPathMeasure.getLength();
        while (mPathMeasure.nextContour()) {
            mLength += mPathMeasure.getLength();
        }
        Log.d(TAG, "文字路径总长度=" + mLength);
    }

### 文字路径的同步绘画 ###

实现思路:	根据init时候获取的总长度mLengthSum和比例progress，来求取将要绘画的文字路径部分的长度mStop，然后用一个while循环使得mPathMeasure定位到最后一段Path片段，在这期间把循环的到片段都加入到要绘画的目标路径mDst，然后最后在按照剩下的长度截取最后一段Path


核心代码:

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        //重置绘制路径
        drawPath.reset();
        //重置路径测量
        mPathMeasure.setPath(mTextPath, false);
        //当前绘制临界值
        float stop = mLength * mProgress;
	//        Log.d(TAG, "stop=" + stop);
        float current = mPathMeasure.getLength();
        while (stop >= current) {
            mPathMeasure.getSegment(0, current, drawPath, true);
            stop -= current;
            if (!mPathMeasure.nextContour())
                break;
            current = mPathMeasure.getLength();
        }
        mPathMeasure.getSegment(0, stop, drawPath, true);


	//        canvas.drawText(mText,0,mHeight,mPaint);
        canvas.drawPath(drawPath, mPaint);
    }

### 文字路径的异步绘制 ###

实现思路:每个笔画作为一个路径,根据进度计算要绘制的部分,添加到目标路径中绘制出来

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        //重置绘制路径
        drawPath.reset();
        //充值路径测量
        mPathMeasure.setPath(mTextPath, false);
        while (mPathMeasure.nextContour()){
            mPathMeasure.getSegment(0,mPathMeasure.getLength()*mProgress,drawPath,true);
        }

	//        canvas.drawText(mText,0,mHeight,mPaint);
        canvas.drawPath(drawPath, mPaint);
    }

### 文字路径的箭头特效 ###

画笔特效原理:	

具体的原理就是利用PathMeasurel类的getPosTan(float distance, float pos[], float tan[])方法，在每次绘画文字路径的时候调用drawPaintPath()来绘画附近的mPaintPath，然后在ondraw()画出来就好了：

箭头原理:
	
根据传入的当前点与上一个点之间的速度方向，来使箭头方向始终向前。

所以这个Path就应该是：在前进速度的反方向，以当前绘画点为起点，以一定夹角画出两条直线：


    //绘制箭头
        if (mProgress == 0)
            return;
        mPaintPath.reset();
        float[] position = new float[2];
        float[] tan = new float[2];
        mPathMeasure.getPosTan(stop, position, tan);
	//        Log.d(TAG, "position=" + position[0] + "," + position[1]);
	//        Log.d(TAG, "tan=" + tan[0] + "," + tan[1]);
        double tanAngle = Math.atan2(tan[1], tan[0]);
        float degree = (float) (tanAngle / Math.PI * 180);
        Log.d(TAG, "切线角度=" + degree);

	//        Log.d(TAG, "tanAngle=" + tanAngle);
        double deltaX = Math.cos(ANGLE) * ARROW_LENGH;
        double deltaY = Math.sin(ANGLE) * ARROW_LENGH;
        mPaintPath.moveTo((float) (position[0] - deltaX), (float) (position[1] - deltaY));
        mPaintPath.lineTo(position[0], position[1]);
        mPaintPath.lineTo((float) (position[0] - deltaX), (float) (position[1] + deltaY));
        Matrix matrix = new Matrix();
        //消失动画180度旋转
        matrix.postRotate(degree+180, position[0], position[1]);
        mPaintPath.transform(matrix);
        canvas.drawPath(mPaintPath, mPaint);
	//        canvas.drawCircle(position[0],position[1],8,mPaint);

### 文字路径的火花特效 ###

火花原理:

是箭头特效的引申，就是在箭头的基础上加多几个角度随机，长度随机的箭头，然后把箭头的线段切成随机的段数(段长递增)，就成了火花：

    //绘制火花
        if (mProgress == 0)
            return;
        float[] position = new float[2];
        float[] tan = new float[2];
        mPathMeasure.getPosTan(stop, position, tan);
	//        Log.d(TAG, "position=" + position[0] + "," + position[1]);
	//        Log.d(TAG, "tan=" + tan[0] + "," + tan[1]);
        double tanAngle = Math.atan2(tan[1], tan[0]);
        float degree = (float) (tanAngle / Math.PI * 180);
	//        Log.d(TAG, "切线角度=" + degree);
        mPaintPath.reset();
        for (int i = 0; i < ARROW_NUM; i++) {
	//        Log.d(TAG, "tanAngle=" + tanAngle);
            double angle = new Random().nextDouble() * ANGLE;
            int arrowLength = new Random().nextInt(ARROW_LENGH);
            double deltaX = Math.cos(angle) * arrowLength;
            double deltaY = Math.sin(angle) * arrowLength;
            //切割虚线
            int segment = new Random().nextInt(SEGMENT_MAX)+2;
            float startX = position[0];
            float starty = position[1];
            for (int j = 0; j < segment; j++) {
                if (j % 3 == 0) {
                    mPaintPath.moveTo(startX, starty);
                    mPaintPath.lineTo((float) (startX - deltaX / segment), (float) (starty - deltaY / segment));
                }
                startX -= deltaX / segment;
                starty -= deltaY / segment;
            }
            startX = position[0];
            starty = position[1];
            for (int j = 0; j < segment; j++) {
                if (j % 3 == 0) {
                    mPaintPath.moveTo(startX, starty);
                    mPaintPath.lineTo((float) (startX - deltaX / segment), (float) (starty + deltaY / segment));
                }
                startX -= deltaX / segment;
                starty += deltaY / segment;
            }
	//        canvas.drawCircle(position[0],position[1],8,mPaint);
        }
        Matrix matrix = new Matrix();
        //消失动画180度旋转
        matrix.postRotate(degree + 180, position[0], position[1]);
        mPaintPath.transform(matrix);
        canvas.drawPath(mPaintPath, mPaint);