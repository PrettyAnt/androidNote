# 1.HelloChart的演示 #
![](/imgs/chart/hello_line.png)

![](/imgs/chart/hello_line.gif)

# 2.目标效果 #

![](/imgs/chart/line1.png)

实现分析:

1.图表绘制:绘制坐标轴(点,线,文字)-->绘制折线或曲线(绘制路径)

2.实体类:点(横纵坐标),坐标轴(值,标签)

3.数据转换:坐标轴:根据值计算在控件的位置,点(根据坐标位置计算对应在控件的位置)

4.暴露设置数据的接口(设置坐标轴,设置数据源)

坐标的实体类:

    /**
	 * 坐标实体类
	 * Created by 曾丽 on 2017/11/6.
	 */
	
	public class AxisData {

    /**
     * 值
     */
    public int value;

    /**
     * 标签文字
     */
    public String label;

    /**
     * 相对于原点的偏移位置
     */
    public float offset;

    public AxisData(int value) {
        this.value = value;
        //不传标签时,默认显示值
        this.label = value + "";
    }

    public AxisData(int value, String label) {
        this.value = value;
        this.label = label;
    }
	}

点的实体类:

	/**
	 * 点的实体类
	 * Created by 曾丽 on 2017/11/6.
	 */
	
	public class PointData {

    /**
     * 横坐标
     */
    public int x;
    /**
     * 纵坐标
     */
    public int y;

    public PointData(int x, int y) {
        this.x = x;
        this.y = y;
    }

    /**
     * 距离控件左边的距离
     */
    public float left;

    /**
     * 距离控件顶部的距离
     */
    public float top;

	}

线形图控件:


	/**
	 * 线性图控件
	 * Created by 曾丽 on 2017/11/6.
	 */
	
	public class LineChartView1 extends View {

    /**
     * 控件间隔
     */
    public static float PADDING = 50;

    //数据源
    private ArrayList<PointData> mDatas;

    //x轴
    private ArrayList<AxisData> mAxisX;

    //y轴
    private ArrayList<AxisData> mAxisY;

    //宽高
    private int mWidth, mHeight;

    /**
     * 右边界,上边界
     */
    private float mRightBorder, mTopBoarder;

    /**
     * 起点位置
     */
    private PointData mOrigin = new PointData(0, 0);

    //画笔
    private Paint mPaint = new Paint();

    //线条画笔
    private Paint mPaintLine = new Paint();

    public LineChartView1(Context context) {
        super(context, null);
    }

    public LineChartView1(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        //初始化画笔
        mPaint = new Paint();
        mPaint.setStyle(Paint.Style.STROKE);
        mPaint.setAntiAlias(true);
        mPaint.setColor(Color.GRAY);
        mPaint.setTextSize(15);

        //初始化线条画笔
        mPaintLine = new Paint();
        mPaintLine.setStyle(Paint.Style.STROKE);
        mPaintLine.setAntiAlias(true);
        mPaintLine.setColor(Color.BLUE);

    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        //记录当前view的宽高
        mWidth = w;
        mHeight = h;
        //计算起点位置
        mOrigin.left = PADDING;
        mOrigin.top = mHeight - PADDING;
        //计算边界
        mRightBorder = mWidth - PADDING;
        mTopBoarder = PADDING;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        //绘制坐标轴
        //绘制直线
        canvas.drawLine(mOrigin.left, mOrigin.top, mRightBorder, mOrigin.top, mPaint);
        canvas.drawLine(mOrigin.left, mOrigin.top, mOrigin.left, mTopBoarder, mPaint);
        //绘制箭头
        canvas.drawLine(mRightBorder, mOrigin.top, mRightBorder - 5, mOrigin.top + 3, mPaint);
        canvas.drawLine(mRightBorder, mOrigin.top, mRightBorder - 5, mOrigin.top - 3, mPaint);
        canvas.drawLine(mOrigin.left, mTopBoarder, mOrigin.left - 3, mTopBoarder + 5, mPaint);
        canvas.drawLine(mOrigin.left, mTopBoarder, mOrigin.left + 3, mTopBoarder + 5, mPaint);
        //坐标文字
        if (mAxisX == null || mAxisY == null)
            return;
        //绘制横轴坐标
        //计算文字高度
        float textHeight = mPaint.ascent() - mPaint.descent();
        float xStep = (mRightBorder - mOrigin.left) / (mAxisX.size() + 1);
        for (int i = 0; i < mAxisX.size(); i++) {
            AxisData data = mAxisX.get(i);
            data.offset = xStep * (i + 1);
            canvas.drawText(data.label, mOrigin.left + data.offset, mOrigin.top - textHeight, mPaint);
        }
        //绘制纵轴坐标
        float yStep = (mOrigin.top - mTopBoarder) / (mAxisY.size() + 1);
        for (int i = 0; i < mAxisY.size(); i++) {
            AxisData data = mAxisY.get(i);
            data.offset = yStep * (i + 1);
            //计算文字宽度
            float textWidth = mPaint.measureText(data.label + " ");
            canvas.drawText(data.label, mOrigin.left - textWidth, mOrigin.top - data.offset, mPaint);
        }
        //绘制线条
        if (mDatas == null)
            return;
        //横纵坐标最大值
        float xMax = mAxisX.get(mAxisX.size() - 1).value;
        float yMax = mAxisY.get(mAxisY.size() - 1).value;
        //横纵轴有效长度
        float xLength = xStep * mAxisX.size();
        float yLength = yStep * mAxisY.size();
        Path path = new Path();
        for (int i = 0; i < mDatas.size(); i++) {
            PointData point = mDatas.get(i);
            point.left = mOrigin.left + point.x / xMax * xLength;
            point.top = mOrigin.top - point.y / yMax * yLength;
            //绘制点
            canvas.drawPoint(point.left,point.top,mPaintLine);
            canvas.drawCircle(point.left,point.top,3,mPaintLine);
            //设置路径
            if(i==0){
                path.moveTo(point.left,point.top);
            }else {
                path.lineTo(point.left,point.top);
            }
        }
        canvas.drawPath(path,mPaintLine);
    }

    /**
     * 设置坐标轴
     *
     * @param axisX 横坐标
     * @param axisY 纵坐标
     */
    public void setAxis(ArrayList<AxisData> axisX, ArrayList<AxisData> axisY) {
        this.mAxisX = axisX;
        this.mAxisY = axisY;
        invalidate();
    }

    /**
     * 数值数据集
     *
     * @param points 点的集合
     */
    public void setPoints(ArrayList<PointData> points) {
        this.mDatas = points;
        invalidate();
    }

	}