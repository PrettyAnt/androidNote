# 1.Hellochart的饼状图演示 #
![](/imgs/chart/hello_pie.gif)

项目中对hellochart的使用:

1.数据转换:接口数据-->效果图

2.数据转换:效果图数据-->hellochart的图表模型

3.Api调用:图表的设置和绘制


# 2.目标效果 #
![](/imgs/chart/pie1.png)

### 实现分析 ###
1.图形的绘制:连续绘制多个扇形,个数取决于数据源

2.饼状图实体类的创建:名称,值

3.数据的转换:计算百分比,扇形角度

4.暴露设置数据的接口

    /**
	 * 饼状图的实体类
	 * Created by 曾丽 on 2017/11/2.
	 */
	
	public class PieData {

    //用户关心的数据
    public String name; //姓名
    public float value;//数值
    public float percent;//百分比

    //非用户关心数据
    public int color;//颜色
    public float angle;//

    /**
     * 构造饼状图的一个分区
     *
     * @param name  名称
     * @param value 该分区的数值
     */
    public PieData(String name, float value) {
        this.name = name;
        this.value = value;
    }
	}

	/**
	 * 饼状图控件ver1.0
	 * <p>
	 *     实现饼状图的绘制
	 * </p>
	 * Created by 曾丽 on 2017/11/2.
	 *
	 * @author 曾丽
	 */
	
	public class PieView1 extends View {

    // 颜色表
    private int[] mColors = {0xFFCCFF00, 0xFF6495ED, 0xFFE32636, 0xFF800000, 0xFF808000, 0xFFFF8C69, 0xFF808080,
            0xFFE6B800, 0xFF7CFC00};

    //饼状图初始绘制角度,默认为0
    private float mStartAngle = 0;

    //数据源
    private ArrayList<PieData> mDatas;

    //宽高
    private int mWidth, mHeight;

    //画笔
    private Paint mPaint = new Paint();


    public PieView1(Context context) {
        super(context, null);
    }

    public PieView1(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        //初始化画笔
        mPaint.setStyle(Paint.Style.FILL);
        mPaint.setAntiAlias(true);
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        //记录当前view的宽高
        mWidth = w;
        mHeight = h;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        //绘制饼状图
        //数据为空时,返回
        if (mDatas == null)
            return;
        float currentStartAngle = mStartAngle;//绘制的起始角度
        canvas.translate(mWidth / 2, mHeight / 2);//将画布坐标原点移动到中心位置
        //计算饼状图的半径,去宽高的较小值,取0.8的系数给四周留间距
        float r = (float) (Math.min(mWidth, mHeight) / 2 * 0.8);
        RectF rect = new RectF(-r, -r, r, r);//饼状图绘制区域

        //遍历数据源,一块块绘制
        for (int i = 0; i < mDatas.size(); i++) {
            PieData data = mDatas.get(i);
            mPaint.setColor(data.color);
            canvas.drawArc(rect, currentStartAngle, data.angle, true, mPaint);
            currentStartAngle += data.angle;
        }
    }

    /**
     * 设置数据源
     *
     * @param datas
     */
    public void setDatas(ArrayList<PieData> datas) {
        this.mDatas = datas;
        initData();
        invalidate();
    }

    /**
     * 数据初始化
     * <p>
     * 源数据只有名称和数值,需要计算出百分比和角度,颜色取默认值
     * </P>
     */
    private void initData() {
        //空数据,返回
        if (mDatas == null || mDatas.isEmpty())
            return;
        float sumValue = 0;//数值总和
        for (int i = 0; i < mDatas.size(); i++) {
            PieData data = mDatas.get(i);

            sumValue += data.value;//计算数值和

            int j = i % mColors.length;//设置颜色
            data.color = mColors[j];
        }

        float sumAngle = 0;
        for (int i = 0; i < mDatas.size(); i++) {
            PieData data = mDatas.get(i);

            data.percent = data.value / sumValue;//计算百分比
            data.angle = data.percent * 360;

            sumAngle += data.angle;

        }
        Log.d(TAG,"sumAngle="+sumAngle);
    }
	}

# 3.添加数值 #
![](/imgs/chart/pie2.png)

### 实现分析 ###
1.图形的绘制:绘制多条直线,绘制多个文字,个数取决于数据源

2.计算直线的起始点,绘制直线

3.计算文字的位置,根据象限做左边处理,绘制文字

	    /**
	 * 饼状图控件ver2.0
	 * <p>
	 * 在1.0的基础上增加绘制数值
	 * </p>
	 * Created by 曾丽 on 2017/11/2.
	 *
	 * @author 曾丽
	 */
	
	public class PieView2 extends View {

	...
   
    /**
     * 图形的画笔
     */
    private Paint mPaint = new Paint();

    /**
     * 文字的画笔
     */
    private Paint mPaintText = new Paint();
    private DecimalFormat mDecimalFormat;


    public PieView2(Context context) {
        super(context, null);
    }

    public PieView2(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        //初始化图形画笔
        mPaint.setStyle(Paint.Style.FILL);
        mPaint.setAntiAlias(true);
        //初始化文字画笔
        mPaintText.setStyle(Paint.Style.STROKE);
        mPaintText.setColor(Color.BLACK);
        mPaintText.setStrokeWidth(1);
        mPaintText.setAntiAlias(true);
        mPaintText.setTextSize(18);
        //初始化小数格式
        mDecimalFormat = new DecimalFormat("0.0");
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        ...

        //遍历数据源,一块块绘制
        for (int i = 0; i < mDatas.size(); i++) {
            PieData data = mDatas.get(i);
            mPaint.setColor(data.color);
            //绘制扇形
            canvas.drawArc(rect, currentStartAngle, data.angle, true, mPaint);

            //绘制直线,长度为10px
            float angle = currentStartAngle + data.angle / 2;
            //计算起点
            float startX = (float) (Math.cos(2*Math.PI / 360*angle) * r);
            float startY = (float) (Math.sin(2*Math.PI / 360*angle) * r);
            //计算终点
            float endX = (float) (Math.cos(2*Math.PI / 360*angle) * (r + 30));
            float endY = (float) (Math.sin(2*Math.PI / 360*angle) * (r + 30));
            Log.d(TAG, "startx=" + startX + ";startY=" + startY + ";endX=" + endX + ";endY=" + endY);
            canvas.drawLine(startX, startY, endX, endY, mPaintText);

            //绘制数值
            String value = mDecimalFormat.format(data.value);
            //文字宽高
            float textH = mPaintText.descent()- mPaintText.ascent();
            float textW = mPaintText.measureText(value);
            //文字位置
            float textX = endX;
            float textY = endY;
            if(endX>0&&endY>0){
                //第一象限,y坐标下移动1/2文字高度
                textY += textH/2;
            }else if(endX<0&&endY>0){
                //第二象限,y坐标下移动1/2文字高度,x左边左移动文字宽度
                textY += textH/2;
                textX -= textW;
            }else if(endX<0&&endY<0){
                //第三象限,,x左边左移动文字宽度
                textX -= textW;
            }else if(endX>0&&endY<0){
                //第四象限,不处理
            }
            canvas.drawText(value,textX,textY,mPaintText);

            currentStartAngle += data.angle;
        }

    }

	...

	
# 4.添加空心圆环和间隔 #

目标效果:
![](/imgs/chart/pie3.png)

### 实现分析 ###
图形的实现: 绘制路径:画大圆圆弧-->arcto小圆圆弧--close

    /**
	 * 饼状图控件ver3.0
	 * <p>
	 * 在2.0的基础上添加空心和间隔效果
	 * </p>
	 * Created by 曾丽 on 2017/11/2.
	 *
	 * @author 曾丽
	 */
	
	public class PieView3 extends View {

    /**
     * 空心加间隔效果
     */
    private boolean explode;

    /**
     * 间隔角度大小
     */
    private int explodeAngle = 5;

    ...

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        //绘制饼状图
        //数据为空时,返回
        if (mDatas == null)
            return;
        float currentStartAngle = mStartAngle;//绘制的起始角度
        canvas.translate(mWidth / 2, mHeight / 2);//将画布坐标原点移动到中心位置
        //计算饼状图的半径,去宽高的较小值,取0.8的系数给四周留间距
        float r = (float) (Math.min(mWidth, mHeight) / 2 * 0.8);
        RectF rect = new RectF(-r, -r, r, r);//饼状图绘制区域

        //遍历数据源,一块块绘制
        for (int i = 0; i < mDatas.size(); i++) {
            PieData data = mDatas.get(i);
            mPaint.setColor(data.color);
            if (explode) {
                //绘制路径(两端圆弧)
                Path path = new Path();
                //不是最佳间隔绘制方案,适配可能不完美    TODO
                float bigAngle = data.angle - explodeAngle;//添加间隔后实际扫过的大圆弧度
                float smallAngle = data.angle - 1.3f*explodeAngle;//添加间隔后实际扫过的大圆弧度
                path.addArc(rect,currentStartAngle,bigAngle);
                RectF smallRectF = new RectF(-r * 0.7f, -r * 0.7f, r * 0.7f, r * 0.7f);
                path.arcTo(smallRectF,currentStartAngle+smallAngle,-smallAngle);
                path.close();
                canvas.drawPath(path,mPaint);
            } else {
                //绘制扇形
                canvas.drawArc(rect, currentStartAngle, data.angle, true, mPaint);
            }

           ...
        }

    }

    /**
     * 设置空心+间隔效果
     *
     * @param explode
     */
    public void setExplode(boolean explode) {
        this.explode = explode;
        invalidate();
    }

    public void setExplodeAngle(int explodeAngle) {
        this.explodeAngle = explodeAngle > 20 ? 20 : explodeAngle;
        invalidate();
    }
	
	...

	}

# 5.添加点击事件和选中效果 #
目标效果:
![](/imgs/chart/pie_check.gif)

### 实现分析 ###
点击的判断:使用Region类的contain方法,按下的时候判断为点击了
选中的实现:点击时重新绘制,将选中的饼状图外圆弧半径增大

    /**
	 * 饼状图控件ver4.0
	 * <p>
	 * 在3.0的基础上添加点击事件和选中效果
	 * </p>
	 * Created by 曾丽 on 2017/11/2.
	 *
	 * @author 曾丽
	 */
	
	public class PieView4 extends View {

    ...

    /**
     * 控件区域
     */
    private Region mGlobalRegion;

    /**
     * 变换矩阵
     */
    private Matrix mConvertMatrix;

    /**
     * 图表点击事件
     */
    private PieClickListener listener;

    /**
     * 选中的图标序列号
     */
    private int mSelectedIndex = -1;

    /**
     * 选中的饼状图的增量半径
     */
    private int selectecDelta = 20;

    ...

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        //绘制饼状图
        //数据为空时,返回
        if (mDatas == null)
            return;
        float currentStartAngle = mStartAngle;//绘制的起始角度
        canvas.translate(mWidth / 2, mHeight / 2);//将画布坐标原点移动到中心位置
        canvas.getMatrix().invert(mConvertMatrix);
        //计算饼状图的半径,去宽高的较小值,取0.8的系数给四周留间距
        float r = (float) (Math.min(mWidth, mHeight) / 2 * 0.8);
        RectF rect = new RectF(-r, -r, r, r);//饼状图绘制区域
        RectF seletedRect = new RectF(-r-selectecDelta, -r-selectecDelta, r+selectecDelta, r+selectecDelta);//选中时候饼状图绘制区域

        //遍历数据源,一块块绘制
        for (int i = 0; i < mDatas.size(); i++) {
            PieData data = mDatas.get(i);
            mPaint.setColor(data.color);
            if (explode) {
                //绘制路径(两端圆弧)
                Path path = new Path();
                //不是最佳间隔绘制方案,适配可能不完美    TODO
                float bigAngle = data.angle - explodeAngle;//添加间隔后实际扫过的大圆弧度
                float smallAngle = data.angle - 1.3f * explodeAngle;//添加间隔后实际扫过的大圆弧度
                if(i == mSelectedIndex){
                    //选中效果
                    path.addArc(seletedRect, currentStartAngle, bigAngle);
                }else {
                    //默认效果
                    path.addArc(rect, currentStartAngle, bigAngle);
                }
                RectF smallRectF = new RectF(-r * 0.7f, -r * 0.7f, r * 0.7f, r * 0.7f);
                path.arcTo(smallRectF, currentStartAngle + smallAngle, -smallAngle);
                path.close();
                mRegions.get(i).setPath(path,mGlobalRegion);
                canvas.drawPath(path, mPaint);
            } else {
                //绘制扇形
                canvas.drawArc(rect, currentStartAngle, data.angle, true, mPaint);
            }

            ...
        }

    }

    public void setPieClickListener(PieClickListener listener) {
        this.listener = listener;
    }


    @Override
    public boolean onTouchEvent(MotionEvent event) {
        switch (event.getAction()){
            case MotionEvent.ACTION_DOWN:
                Log.d(TAG,"onTouchEvent:x="+x+";y="+y);
                float[] point = new float[2];
                float x = event.getX();
                float y = event.getY();
                point[0] = x;
                point[1] = y;
                mConvertMatrix.mapPoints(point);
                Log.d(TAG,"转换后:x="+point[0]+";y="+point[1]);
                //区域判断
                for (int i = 0;i<mRegions.size();i++){
                    Region region = mRegions.get(i);
                    if(region.contains((int)point[0],(int)point[1])){
                        Log.d(TAG,"点击了="+i);
                        mSelectedIndex = i;
                        invalidate();
                        if(listener!=null){
                            listener.onPieClick(i,mDatas.get(i));
                        }
                    }
                }
                break;
        }
        return true;
    }

	...	

	}
