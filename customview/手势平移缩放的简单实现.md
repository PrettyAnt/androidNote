# 参考

[Android 手势检测实战 打造支持缩放平移的图片预览效果（上）](https://blog.csdn.net/lmj623565791/article/details/39474553)

# 目标效果 #
![](/imgs/movescale/movescale1.gif)

# 实现思路 #
1.核心代码,缩放手势的监听:


    public class ZoomImageView extends AppCompatImageView implements ScaleGestureDetector.OnScaleGestureListener, View.OnTouchListener, ViewTreeObserver.OnGlobalLayoutListener {

    public static final String TAG = "ZoomImageView";

    /**
     * 允许的最大缩放比例
     */
    public static final float SCALE_MAX = 4.0f;

    /**
     * 初始的缩放比例,当图片宽高大于控件时,缩放比例小于1
     */
    private float initScale = 1.0f;

    /**
     * 变化
     */
    private float[] matrixValues = new float[9];

    private boolean once = true;

    /**
     * 缩放的手势检测器
     */
    private ScaleGestureDetector mScaleGestureDetector;

    /**
     * 缩放的变换矩阵
     */
    private Matrix mScaleMatrix = new Matrix();

    public ZoomImageView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        super.setScaleType(ScaleType.MATRIX);
        mScaleGestureDetector = new ScaleGestureDetector(context, this);
        this.setOnTouchListener(this);
    }

    @Override
    public boolean onScale(ScaleGestureDetector scaleGestureDetector) {

        //准备缩放的比例
        float scaleFactor = scaleGestureDetector.getScaleFactor();

        if (getDrawable() == null)
            return true;

       
            mScaleMatrix.postScale(scaleFactor, scaleFactor, scaleGestureDetector.getFocusX(), scaleGestureDetector.getFocusY());
       
        return true;
    }

    @Override
    public boolean onScaleBegin(ScaleGestureDetector scaleGestureDetector) {
        return true;
    }

    @Override
    public void onScaleEnd(ScaleGestureDetector scaleGestureDetector) {

    }

    @Override
    public boolean onTouch(View view, MotionEvent motionEvent) {
        return mScaleGestureDetector.onTouchEvent(motionEvent);
    }

	}

2.默认缩放:

2.1.平移图片到控件中心不缩放

2.2.当图片小于图片宽高时,不缩放

当图片大于控件宽高时,缩放到控件宽或高(较小值),平移到控件中心

    @Override
    protected void onAttachedToWindow() {
        super.onAttachedToWindow();
        getViewTreeObserver().addOnGlobalLayoutListener(this);
    }

    @Override
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        getViewTreeObserver().removeGlobalOnLayoutListener(this);
    }

    @Override
    public void onGlobalLayout() {
        if (once) {
            Drawable drawable = getDrawable();
            if (drawable == null)
                return;

            //控件宽高
            int width = getWidth();
            int height = getHeight();
            Log.d(TAG, "width=" + width + ";height=" + height);
            //图片宽高
            int intrinsicWidth = drawable.getIntrinsicWidth();
            int intrinsicHeight = drawable.getIntrinsicHeight();
            Log.d(TAG, "图片宽高,宽=" + intrinsicWidth + ";高=" + intrinsicHeight);

            //计算默认的缩放比例(当图片宽大于控件宽高时,缩放到控件宽高;否则不进行缩放)
            float scaleW = width * 1.0f / intrinsicWidth;
            float scaleH = height * 1.0f / intrinsicHeight;
            initScale = (scaleW < 1 || scaleH < 1) ? Math.min(scaleW, scaleH) : 1.0f;
            Log.d(TAG, "初始缩放=" + initScale);

            //将图片移动到控件中心
            mScaleMatrix.postTranslate((width - intrinsicWidth) / 2, (height - intrinsicHeight) / 2);
            //默认缩放
            mScaleMatrix.postScale(initScale, initScale, width / 2, height / 2);
            setImageMatrix(mScaleMatrix);

            once = false;
        }
    }

3.缩放范围的限制:

    @Override
    public boolean onScale(ScaleGestureDetector scaleGestureDetector) {
        //当前的缩放比例
        float scale = getScale();
        //准备缩放的比例
        float scaleFactor = scaleGestureDetector.getScaleFactor();

        if (getDrawable() == null)
            return true;

        //缩放范围控制(当前缩放比例小于最大值时才可以放大,当前缩放比例大于初始缩放时才可以缩小)
        if ((scale < SCALE_MAX && scaleFactor > 1.0f) || (scaleFactor < 1.0f && scale > initScale)) {
            //最大最小值限制
            scaleFactor = scaleFactor * scale < initScale ? initScale / scale : scaleFactor;
            scaleFactor = scaleFactor * scale > SCALE_MAX ? SCALE_MAX / scale : scaleFactor;
            //设置缩放比例
            mScaleMatrix.postScale(scaleFactor, scaleFactor, scaleGestureDetector.getFocusX(), scaleGestureDetector.getFocusY());
      
            setImageMatrix(mScaleMatrix);
        }
        return true;
    }

    /**
     * 获取当前的缩放比例
     *
     * @return
     */
    private float getScale() {
        mScaleMatrix.getValues(matrixValues);
        return matrixValues[Matrix.MSCALE_X];
    }

4.缩放时控制图片显示位置

    @Override
    public boolean onScale(ScaleGestureDetector scaleGestureDetector) {
        //当前的缩放比例
        float scale = getScale();
        //准备缩放的比例
        float scaleFactor = scaleGestureDetector.getScaleFactor();

        if (getDrawable() == null)
            return true;

        //缩放范围控制(当前缩放比例小于最大值时才可以放大,当前缩放比例大于初始缩放时才可以缩小)
        if ((scale < SCALE_MAX && scaleFactor > 1.0f) || (scaleFactor < 1.0f && scale > initScale)) {
            //最大最小值限制
            scaleFactor = scaleFactor * scale < initScale ? initScale / scale : scaleFactor;
            scaleFactor = scaleFactor * scale > SCALE_MAX ? SCALE_MAX / scale : scaleFactor;
            //设置缩放比例
            mScaleMatrix.postScale(scaleFactor, scaleFactor, scaleGestureDetector.getFocusX(), scaleGestureDetector.getFocusY());
            //控制图片显示范围
            checkBoarderAndCenter();
            setImageMatrix(mScaleMatrix);
        }
        return true;
    }

    /**
     * 缩放时控制显示范围和缩放中心
     */
    private void checkBoarderAndCenter() {
        RectF rectF = getMatrixRecf();
        //水平偏移量
        float deltaX = 0;
        //竖直偏移量
        float deltaY = 0;

        //控件宽高
        int width = getWidth();
        int height = getHeight();

        //如果图片宽大于控件宽,水平不能留白;如果图片高大于控件高,竖直不能留白   TODO

        //当图片宽或高小于控件宽高时,始终居中显示
        if(rectF.width()<width||rectF.height()<height){
            deltaX = (width-rectF.width())/2-rectF.left;
            deltaY = (height-rectF.height())/2-rectF.top;
        }

        mScaleMatrix.postTranslate(deltaX,deltaY);
    }

    /**
     * 获取缩放后的图片范围
     * @return
     */
    private RectF getMatrixRecf() {
        Matrix matrix = mScaleMatrix;
        RectF rectF = new RectF();
        Drawable drawable = getDrawable();
        rectF.set(0,0,drawable.getIntrinsicWidth(),drawable.getIntrinsicHeight());
        matrix.mapRect(rectF);
        return rectF;
    }

#  添加手势平移 #

目标效果:

![](/imgs/movescale/movescale2.gif)

核心代码:

    @Override
    public boolean onTouch(View view, MotionEvent motionEvent) {
        mScaleGestureDetector.onTouchEvent(motionEvent);
        float x = motionEvent.getX();
        float y = motionEvent.getY();
        switch (motionEvent.getActionMasked()) {
            case MotionEvent.ACTION_DOWN:
            case MotionEvent.ACTION_POINTER_DOWN:
                mLastX = x;
                mLastY = y;
                Log.d(TAG, "down:x=" + mLastX + ";y=" + mLastY);
                break;
            case MotionEvent.ACTION_MOVE:
                if (mDragable) {
                    float deltaX = x - mLastX;
                    float deltaY = y - mLastY;
                    mCheckBoarderX = mCheckBoarderY = true;
                    Log.d(TAG, "move:deltaX=" + deltaX + ";deltaY=" + deltaY);
                    mScaleMatrix.postTranslate(deltaX, deltaY);
                    mLastX = x;
                    mLastY = y;
                    setImageMatrix(mScaleMatrix);
                }
                break;
            case MotionEvent.ACTION_UP:
            case MotionEvent.ACTION_POINTER_UP:
                break;
        }
        return true;
    }

平移的边界限制:按下的位置要在图片内部&跟踪第一个手指&拖动时处理空白的情况

     @Override
    public boolean onTouch(View view, MotionEvent motionEvent) {
        mScaleGestureDetector.onTouchEvent(motionEvent);
        //只允许单手指平移
        float x = motionEvent.getX();
        float y = motionEvent.getY();
        RectF recf = getMatrixRecf();
        switch (motionEvent.getActionMasked()) {
            case MotionEvent.ACTION_DOWN:
            case MotionEvent.ACTION_POINTER_DOWN:
                //第一个手指按下时&下的位置在图片内部->可以拖动
                if (motionEvent.getPointerId(motionEvent.getActionIndex()) == 0 && recf.contains(x, y)) {
                    mDragable = true;
                }
                mLastX = x;
                mLastY = y;
                Log.d(TAG, "down:x=" + mLastX + ";y=" + mLastY);
                break;
            case MotionEvent.ACTION_MOVE:
                if (mDragable) {
                    float deltaX = x - mLastX;
                    float deltaY = y - mLastY;
                    mCheckBoarderX = mCheckBoarderY = true;
                    //如果图片宽度小于控件宽度-->禁止水平移动
                    if (recf.width() <= getWidth()) {
                        mCheckBoarderX = false;
                        deltaX = 0;
                    }
                    //如果图片高度小于控件高度-->禁止竖直滑动
                    if (recf.height() <= getHeight()) {
                        mCheckBoarderY = false;
                        deltaY = 0;
                    }
                    Log.d(TAG, "move:deltaX=" + deltaX + ";deltaY=" + deltaY);
                    mScaleMatrix.postTranslate(deltaX, deltaY);
                    mLastX = x;
                    mLastY = y;
                    checkBoarders();
                    setImageMatrix(mScaleMatrix);
                }
                break;
            case MotionEvent.ACTION_UP:
            case MotionEvent.ACTION_POINTER_UP:
                //第一个手指抬起时-->禁止拖动
                if (motionEvent.getPointerId(motionEvent.getActionIndex()) == 0) {
                    mDragable = false;
                }
                break;
        }
        return true;
    }
	
平移的边界限制:

	/**
     * 平移的边界校验
     */
    private void checkBoarders() {
        RectF rect = getMatrixRecf();
        int width = getWidth();
        int height = getHeight();
        float deltaX = 0.0f;
        float deltaY = 0.0f;
        if (rect.left > 0 && mCheckBoarderX) {
            deltaX = -rect.left;
        }
        if (rect.right < width && mCheckBoarderX) {
            deltaX = width - rect.right;
        }
        if (rect.top > 0 && mCheckBoarderY) {
            deltaY = -rect.top;
        }
        if (rect.bottom < height && mCheckBoarderY) {
            deltaY = height - rect.bottom;
        }
        mScaleMatrix.postTranslate(deltaX, deltaY);
    }


# 双击放大缩小 #
![](/imgs/movescale/scaleMove3.gif)

实现思路:

GestureDetector检测双击事件:

如果当前缩放小于2-->放大到2

如果当前缩放大于等于2小于4-->放大到4

如果当前缩放等于4-->恢复到原始缩放

     public ZoomImageView3(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        mGestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() {
            @Override
            public boolean onDoubleTap(MotionEvent e) {
                Log.d(TAG, "onDoubleTap");
                //双击策略:
                mDoublePoint = new Point((int) e.getX(), (int) e.getY());
                float curScale = getScale();
                if (curScale < 2) {
                    //如果当前缩放小于2,缩放到2
                    mValueAnim = ValueAnimator.ofFloat(curScale, 2);
                } else if (curScale < 4) {
                    //如果当前缩放为2-4之间,缩放到4
                    mValueAnim = ValueAnimator.ofFloat(curScale, 4);
                } else if (curScale == 4) {
                    //如果当前缩放为4,恢复默认值
                    mValueAnim = ValueAnimator.ofFloat(curScale, initScale);
                }
                mValueAnim.addUpdateListener(ZoomImageView3.this);
                mValueAnim.setDuration(300);
                mValueAnim.start();
                return true;
            }
        });
    }

    @Override
    public void onAnimationUpdate(ValueAnimator valueAnimator) {
        float currentScale = getScale();
        float value = (float) valueAnimator.getAnimatedValue();
        float deltaScale = value / currentScale;
        Log.d(TAG, "onAnimationUpdate:curScale=" + currentScale + ";value=" + value + ";deltaScale=" + deltaScale);
        mScaleMatrix.postScale(deltaScale, deltaScale, mDoublePoint.x, mDoublePoint.y);
        checkBoarderAndCenter();
        setImageMatrix(mScaleMatrix);
    }

     @Override
    public boolean onTouch(View view, MotionEvent motionEvent) {
        mGestureDetector.onTouchEvent(motionEvent);
        return true;
    }