# 目标效果 #

![](/imgs/sweep.gif)

# 量测和布局 #

内容部分填充父容器,删除部分摆在父容器右边

    **
	 * 滑动删除控件
	 * Created by hoop on 2017/11/28.
	 */
	
	public class SweepView extends ViewGroup {

    private static final String TAG = "SweepView";

    /**
     * 内容控件
     */
    private View mContentView;
    /**
     * 删除控件
     */
    private View mDelView;

    /**
     * 删除控件的宽度
     */
    private int mDelWidth;
    /**
     * 删除控件的高度
     */
    private int mDelHeight;

    private ViewDragHelper mDragHelper;

    private float mDownX;

    private float mDownY;

    public SweepView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mDragHelper = ViewDragHelper.create(this, new SweepDragCallBack());
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int width = MeasureSpec.getSize(widthMeasureSpec);
        int height = MeasureSpec.getSize(heightMeasureSpec);
        Log.d(TAG, "onMeasure:width=" + width + ";height=" + height);

        //设置内容部分的大小
        mContentView.measure(widthMeasureSpec, heightMeasureSpec);

        //设置删除部分的大小
        mDelView.measure(MeasureSpec.makeMeasureSpec(mDelWidth, MeasureSpec.EXACTLY),
                MeasureSpec.makeMeasureSpec(mDelHeight, MeasureSpec.EXACTLY));

        //设置容器的大小
        setMeasuredDimension(width, height);
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        Log.d(TAG, "onlayout:left=" + left + ";top=" + top + ";right=" + right + ";bottom=" + bottom);
        //布局内容部分
        int cLeft = 0;
        int cTop = 0;
        int cRitht = mContentView.getMeasuredWidth();
        int cBottom = mContentView.getMeasuredHeight();
        mContentView.layout(cLeft, cTop, cRitht, cBottom);
        //布局删除部分
        int dLeft = cRitht;
        int dTop = 0;
        int dRight = cRitht + mDelWidth;
        int dBottom = mDelHeight;
        mDelView.layout(dLeft, dTop, dRight, dBottom);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        //初始化控件
        mContentView = getChildAt(0);
        mDelView = getChildAt(1);

        //初始化删除控件的宽高
        LayoutParams params = mDelView.getLayoutParams();
        mDelWidth = params.width;
        mDelHeight = params.height;
    }

	}

# 拖动内容部分或者拖动删除部分 #

需要限制拖动的边界,需要联动:

    public class SweepView extends ViewGroup {

    public SweepView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mDragHelper = ViewDragHelper.create(this, new SweepDragCallBack());
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        mDragHelper.processTouchEvent(event);
        return true;
    }

    private class SweepDragCallBack extends ViewDragHelper.Callback {

        @Override
        public boolean tryCaptureView(View child, int pointerId) {
            //内容控件和删除控件允许拖动
            return child == mContentView || child == mDelView;
        }

        @Override
        public int clampViewPositionHorizontal(View child, int left, int dx) {
            Log.d(TAG, "clampViewPositionHorizontal:left=" + left + ";dx=" + dx);
            // child: 拖动的view
            // left: 拖动的view的期望位置和控件的左边距
            // dx: 增量移动的距离

            //边界限制
            if (child == mContentView) {
                //内容控件不允许往右拖
                left = left > 0 ? 0 : left;
                //内容控件往左拖的最大值为删除控件宽度
                left = left < -mDelWidth ? -mDelWidth : left;
            }
            if (child == mDelView) {
                //删除控件左边距最小值
                left = left < mContentView.getMeasuredWidth() - mDelWidth ?
                        mContentView.getMeasuredWidth() - mDelWidth : left;
                //删除控件左边距最大值
                left = left > mContentView.getMeasuredWidth() ? mContentView.getMeasuredWidth() : left;
            }


            //返回值,,目标位置距控件左边距
            return left;
        }

        @Override
        public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {
            super.onViewPositionChanged(changedView, left, top, dx, dy);
            //如果移动的是内容控件,联动删除控件
            if (changedView == mContentView) {
                int dLeft = left + mContentView.getMeasuredWidth();
                int dTop = top;
                int dRight = dLeft + mDelWidth;
                int dBottom = mDelHeight;
                mDelView.layout(dLeft, dTop, dRight, dBottom);
            }
            //如果移动的是删除控件,联动内容控件
            if (changedView == mDelView) {
                int cLeft = left - mContentView.getMeasuredWidth();
                int cTop = top;
                int cRight = left;
                int cBottom = mDelHeight;
                mContentView.layout(cLeft, cTop, cRight, cBottom);
            }
        }

	}

# 手指抬起时平滑滚动到期待位置 #

    @Override
        public void onViewReleased(View releasedChild, float xvel, float yvel) {
            super.onViewReleased(releasedChild, xvel, yvel);
            int left = mDelView.getLeft();
            int visibleDel = mContentView.getMeasuredWidth() - left;
            if (visibleDel < mDelWidth / 2) {
                //如果删除控件的可见部分小于%50-->关闭
                mDragHelper.smoothSlideViewTo(mContentView, 0, 0);
                mDragHelper.smoothSlideViewTo(mDelView, mContentView.getMeasuredWidth(), 0);
            } else {
                //如果删除控件的可见部分大于等于50%-->展开
                mDragHelper.smoothSlideViewTo(mContentView, -mDelWidth, 0);
                mDragHelper.smoothSlideViewTo(mDelView, mContentView.getMeasuredWidth() - mDelWidth, 0);
            }
            ViewCompat.postInvalidateOnAnimation(SweepView.this);
        }

    }

    @Override
    public void computeScroll() {
        if(mDragHelper.continueSettling(true)){
            ViewCompat.postInvalidateOnAnimation(SweepView.this);
        }
    }